### 防抖和节流

#### 防抖 debounce

规定时间内多次触发事件，只执行最后一次。

适用场景：

- 按钮提交场景：防止多次点击提交
- 输入框：当输入最后一个字符才触发

```js
// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。
// immediate是否立即执行
function debounce(func, wait, immediate) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait)
      if (callNow) func.apply(context, args)
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args)
      }, wait);
    }
  }
}
```

#### 节流 throttle

规定时间内多次触发事件，只执行一次。

适用场景：

- 拖拽场景
- 缩放场景resize

```js
function throttle(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args)
      }, wait)
    }
  }
}
```

### 手写发布订阅

```ts
// 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储;

interface CacheProps {
  [key: string]: Array<(data?: any) => void>
}

class Observer {
  private caches: CacheProps = {} // 事件中心

  on(eventName: string, fn: (data?: any) => void) {
    // eventName事件名-独一无二, fn是订阅后执行的自定义行为
    this.caches[eventName] = this.caches[eventName] || []
    this.caches[eventName].push(fn)
  }

  emit(eventName: string, data?: any) {
    // 发布 => 将订阅的事件进行统一执行
    if (this.caches[eventName]) {
      this.caches[eventName].forEach((fn: (data?: any) => void) => fn(data))
    }
  }

  off(eventName: string, fn?: (data?: any) => void) {
    // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息
    if (this.caches[eventName]) {
      const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : []
      this.caches[eventName] = newCaches
    }
  }
}

```

### 返回顶部

```js
function scrollIt(
  destination = 0,
  duration = 200,
  easing = 'linear',
  callback,
) {
  // 曲线图解：https://www.jb51.net/article/86785.htm
  // t的取值为[0,1]
  let easings = {
    // no easing, no acceleration
    linear(t) {
      return t
    },
    // accelerating from zero velocity
    easeInQuad(t) {
      return t * t
    },
    // decelerating to zero velocity
    easeOutQuad(t) {
      return t * (2 - t)
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
    },
    // accelerating from zero velocity
    easeInCubic(t) {
      return t * t * t
    },
    // decelerating to zero velocity
    easeOutCubic(t) {
      return --t * t * t + 1
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
    },
    // accelerating from zero velocity
    easeInQuart(t) {
      return t * t * t * t
    },
    // decelerating to zero velocity
    easeOutQuart(t) {
      return 1 - --t * t * t * t
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
    },
    // accelerating from zero velocity
    easeInQuint(t) {
      return t * t * t * t * t
    },
    // decelerating to zero velocity
    easeOutQuint(t) {
      return 1 + --t * t * t * t * t
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint(t) {
      return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
    },
  }
  // window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘(刷新)之前执行
  // 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。
  // 换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。
  // requestAnimationFrame()的兼容性封装：先判断是否原生支持各种带前缀的
  // 不行的话就采用延时的方案
  ;(function() {
    let lastTime = 0
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
          let currentTime = new Date().getTime()
          // 16.7ms是1000/60,每一帧需要的毫秒数
          // currentTime - lastTime是两次window.requestAnimationFrame执行的间隔时间
          // 16.7 - (currentTime - lastTime)估计是想让setTimeoutm每执行完回调函数callback刚好到达16.7ms
          // 即在完成callback后刚好一帧结束
          let timeToCall = Math.max(0, 16.7 - (currentTime - lastTime))
          let timer = window.setTimeout(function() {
            callback(currentTime + timeTocall)
          }, timeToCall)
          lastTime = currentTime + timeToCall
          return timer
        }
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
        window.webkitCancelRequestAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.mozCancelRequestAnimationFrame ||
        window.msCancelAnimationFrame ||
        window.msCancelRequestAnimationFrame ||
        window.oCancelAnimationFrame ||
        window.oCancelRequestAnimationFrame ||
        function(id) {
          window.clearTimeout(id)
        }
    }
  })()

  let element = checkElement()
  let start = element.scrollTop // 当前y轴滚动距离
  // Date.now()和new Date().getTime()一样，获取毫秒级时间戳
  // new Date().getTime()兼容性更好
  let startTime = new Date().getTime() // 当前时间

  function scroll() {
    let nowTime = new Date().getTime()
    let time = Math.min(1, (nowTime - startTime) / duration)
    let timeFunction = easings[easing](time)
    element.scrollTop = timeFunction * (destination - start) + start
    if (element.scrollTop === destination) {
      callback && callback() // 回调函数
      return
    }
    window.requestAnimationFrame(scroll)
  }
  scroll()
}

function checkElement() {
  // chrome,safari及一些浏览器对于documentElement的计算标准化
  // 旧版本的chrome,safari及一些浏览器documentElement.scrollTop为undefined
  // 新版本的的chrome,safari的documentElement.scrollTop是有效的，而document.body.scrollTop是固定值0
  let element = document.documentElement.scrollTop
    ? document.documentElement
    : document.body
  return element
}
```

### 触底加载

```js
// 触底的条件：scrollTop + clientHeight >= scrollHeight
//获取页面滚动的距离(被卷去的高)
let scrollTop =
  window.pageYOffset ||
  document.documentElement.scrollTop ||
  document.body.scrollTop

// 获取页面网页可见区域高(不包含边框)
let clientHeight =
  document.documentElement.clientHeight || document.body.clientHeight

// 获取网页全文高（包括被卷去的部分）
let scrollHeight =
  document.documentElement.scrollHeight || document.body.scrollHeight
window.addEventListener(function () {
  if (scrollTop + clientHeight >= scrollHeight) {
    // do something...
  }
})
```



### 文件上传

https://juejin.cn/post/6844903968338870285#heading-17

#### form 表单上传（不推荐）

需要把 form 标签的`enctype`设置为`multipart/form-data`，同时`method`必须为`post`方法。

这种方式上传文件，不需要 js ，而且没有兼容问题，所有浏览器都支持，就是体验很差，**导致页面刷新，页面其他数据丢失**。

```html
<form method="post" action="http://localhost:8100" enctype="multipart/form-data"></form>
```

#### 多文件上传

##### input 标签 type="file"

- accept：规定文件类型，参阅 [IANA MIME 类型](http://www.iana.org/assignments/media-types/)，获得标准 MIME 类型的完整列表

- multiple：允许上传多个文件

```html
<input id="f1" type="file" multiple />
```

##### 请求头 Content-Type

需要在表单中进行文件上传时，就需要使用该格式

```js
headers: {
	'Content-Type': 'multipart/form-data;charset=UTF-8'
}
```

**HTML**

```HTML
<div class="addFiles">
  <input id="f1" type="file" multiple />
</div>
<button id="submit">提交</button>
```

**JS**

```js
let fileMaxCount = 3
let willUploadFile = []
let f1 = document.getElementById('f1')
f1.addEventListener('change', function (e) {
  // fileList 是  FileList对象，其成员是 File 对象
  // 一个 FileList 对象通常来自于一个 HTML <input> 元素的 files 属性
  let fileList = this.files
  if (
    willUploadFile.length > fileMaxCount ||
    fileList.length > fileMaxCount ||
    willUploadFile.length + fileList.length > fileMaxCount
  ) {
    alert('最多只能上传' + fileMaxCount + '个文件')
    return
  }
  // 生成 fileList.length 个块级元素用来显示文件
  for (let i = 0; i < fileList.length; i++) {
    let fileBox = document.createElement('div')
    let fileName = document.createElement('span')
    // 这里为了方便就写了 progress 标签，实际上还是用div实现
    let progress = document.createElement('progress')
    let removeBtn = document.createElement('button')
    // 如果是图片，则可以加上预览功能
    // let img = document.createElement('img')
    // img.src = window.URL.createObjectURL(fileList[i])
    // img.onload = function () {
    //   // 释放内存
    //   window.URL.revokeObjectURL(this.src)
    // }
    fileBox.className = 'fileBox'
    fileName.innerHTML = `<span>${fileList[i].name}</span>`
    removeBtn.innerText = '删除文件'
    removeBtn.addEventListener('click', function () {
      fileBox.remove()
    })
    // fileBox.append(img)
    fileBox.append(fileName)
    fileBox.append(progress)
    fileBox.append(removeBtn)
    document.querySelector('.addFiles').append(fileBox)
    // FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去
    let form = new FormData()
    // 向 FormData 中添加新的属性值，FormData 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值。
    // upload 是与后台约定好的
    form.append('upload', fileList[i])
    willUploadFile.push({
      form,
      progress,
    })
  }
})

// 提交文件请求
function filePost({ url, form, progress }) {
  axios
    .post(url, form, {
      // 需要在表单中进行文件上传时，就需要使用该格式
      headers: {
        'Content-Type': 'multipart/form-data;charset=UTF-8',
      },
      onUploadProgress: event => {
        // 进度条变化
        let complete = ((event.loaded / event.total) * 100).toFixed(2)
        progress.style.width = complete + ' %'
      },
    })
    .catch(e => {
      // 提示上传失败
    })
}

// 文件上传
function sumbit(files) {
  if (files.length === 0) {
    return
  }
  files.forEach(item => {
    filePost({
      url: 'xxx',
      form: item.form,
      progress: item.progress,
    })
  })
}

// 点击提交
document.querySelector('#submit').addEventListener('click', function () {
  sumbit(willUploadFile)
})
```

#### 文件切片

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件
- 服务端保存各段文件
- 浏览器端所有分片上传完成，发送给服务端一个合并文件的请求
- 服务端根据文件标识、类型、各分片顺序进行文件合并

> 每个chunk的上传进度乘以 （chunk.size / file.size），然后将每个chunk的上传进度相加才是总上传进度

```js
// 提交时才对文件切片
function submitUpload() {
  let chunkSize = 2 * 1024 * 1024 // 分割大小，2m
  let file = document.getElementById('f1').files[0]
  // 存储分割块
  let chunks = [],
    token = +new Date(),
    name = file.name,
    chunkCount = 0,
    sendChunkCount = 0

  if (!file) {
    alert('请选择文件')
    return
  }

  //拆分文件
  if (file.size > chunkSize) {
    //拆分文件
    let start = 0,
      end = 0
    while (true) {
      end += chunkSize
      // [start,end)
      let blob = file.slice(start, end)
      console.log()
      start += chunkSize

      if (!blob.size) {
        //拆分结束
        break
      }

      chunks.push(blob)
    }
  } else {
    chunks.push(file.slice(0))
  }

  console.log(chunks)

  chunkCount = chunks.length

  //没有做并发限制，较大文件导致并发过多，tcp 链接被占光 ，需要做下并发控制，比如只有4个在请求在发送
  for (let i = 0; i < chunkCount; i++) {
    let fd = new FormData() //构造FormData对象
    fd.append('token', token)
    fd.append('f1', chunks[i])
    fd.append('index', i)
    xhrSend(fd, function () {
      sendChunkCount += 1
      if (sendChunkCount === chunkCount) {
        console.log('上传完成，发送合并请求')

        let formD = new FormData()
        formD.append('type', 'merge')
        formD.append('token', token)
        formD.append('chunkCount', chunkCount)
        formD.append('filename', name)
        xhrSend(formD)
      }
    })
  }
}

function xhrSend(fd, cb) {
  let xhr = new XMLHttpRequest() //创建对象
  xhr.open('POST', 'http://localhost:8100/', true)

  xhr.onreadystatechange = function () {
    console.log('state change', xhr.readyState)
    if (xhr.readyState == 4 && xhr.status == 200) {
      console.log(xhr.responseText)
      cb && cb()
    }
  }
}
```

#### 文件断点上传

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件

- 为每个分段生成 hash 值，使用 `spark-md5` 库

- 将上传成功的分段信息保存到本地 / 服务器端

- 重新上传时，进行和本地分段 hash 值的对比，如果相同的话则跳过，继续下一个分段的上传

  

#### 下载

`a`标签可以访问下载文件的地址，浏览器帮助进行下载。但是对于浏览器支持直接浏览的txt、png、jpg、gif等文件，是不提供直接下载（可右击从菜单里另存为）的。

为了解决这个直接浏览不下载的问题，可以利用`download`属性。

但只支持下载**同源**下载链接。

如果你尝试下载跨域链接，那么其实`download`的效果就会没了，跟不设置`download`表现一致。即浏览器能预览的还是会预览，而不是下载。

```js
function downloadFile(url, fileName) {
  const link = document.createElement('a')
  link.style.display = 'none'
  link.href = url
  link.download = fileName
  document.body.append(link)
  link.click()
  document.body.removeChild(link)
}

```

> 浏览器处于安全考虑，下载文件保存路径只能在浏览器中设置，或者设置成每次都询问，不能由js代码指定

### ASE加密

```ts
import cryptoJs from 'crypto-js';

// s：要加密的字符串
// salt：盐
export function AES(s: string, salt: string = '默认值') {
  const keys = cryptoJs.enc.Utf8.parse(salt);
  const params = cryptoJs.enc.Utf8.parse(s);
  // 开始加密
  const encryptorStr = cryptoJs.AES.encrypt(params, keys, {
    mode: cryptoJs.mode.ECB,
    padding: cryptoJs.pad.Pkcs7,
  });
  // 返回加密后的转换成 字符串
  return String(encryptorStr);
}

```

### token登录

最近公司在改造接口的请求的验证，之前是登陆后返回一个**token**,在请求的时候动态添加到**header**中，以此来验证身份，当返回**401**直接去重新登录；现在登录返回**token**和**refreshToken**两个参数，拿**token**去添加**header**,当返回**401**时并不直接去登录而是拿**refreshToken**去请求一个接口，刷新得到新的**token**和**refreshToken**，拿到新的**token**再去请求当前返回**401**的接口，如果此时返回**410**则是真正的过期才需要去登录。

#### 解决多次刷新token问题

https://juejin.cn/post/6896682955209441287

```js
finally{
	this.isReflash = false
}
```

