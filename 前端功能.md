### 防抖和节流

#### 防抖 debounce

规定时间内多次触发事件，只执行最后一次。

适用场景：

- 按钮提交场景：防止多次点击提交
- 输入框：当输入最后一个字符才触发

```js
// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。
// immediate是否立即执行
function debounce(func, wait, immediate) {
  let timer;
  return function () {
    const args = arguments;
    if (timer) clearTimeout(timer);
    if (immediate) {
      const callNow = !timer;
      timer = setTimeout(function () {
        timer = null;
      }, wait)
      if (callNow) func.apply(this, args)
    } else {
      timer = setTimeout(function () {
        func.apply(this, args)
      }, wait);
    }
  }
}
```

#### 节流 throttle

规定时间内多次触发事件，只执行一次。

适用场景：

- 拖拽场景
- 缩放场景resize

```js
function throttle(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args)
      }, wait)
    }
  }
}
```

### 手写发布订阅

```typescript
type Fn = (...args: any[]) => void;

interface Events {
    [eventId: string]: Fn;
}

export class EventEmitter {
    private events: Events = {};
    private eventIds: { [eventName: string]: string[]; } = {};

    on(eventName: string, fn: Fn) {
        this.eventIds[eventName] = this.eventIds[eventName] || [];

        const eventId = eventName + "-" + Math.random().toString(16).slice(2);
        this.eventIds[eventName].push(eventId);
        this.events[eventId] = fn;

        return eventId;
    }

    emit(eventName: string, eventId?: string, ...args: any[]) {
        if (eventId && this.eventIds[eventName]?.includes(eventId)) {
            this.events[eventId]?.(...args);
        } else if (this.eventIds[eventName]) {
            this.eventIds[eventName].forEach(eventId => {
                this.events[eventId]?.(...args);
            });
        }
    }

    off(eventName: string, eventId: string) {
        const index = this.eventIds[eventName]?.indexOf(eventId);

        if (index > -1) {
            this.eventIds[eventName].splice(index, 1);
            delete this.events[eventId];
        }
    }
}
```

### 返回顶部

```js
function scrollIt(
  destination = 0,
  duration = 200,
  easing = 'linear',
  callback,
) {
  // 曲线图解：https://www.jb51.net/article/86785.htm
  // t的取值为[0,1]
  let easings = {
    // no easing, no acceleration
    linear(t) {
      return t
    },
    // accelerating from zero velocity
    easeInQuad(t) {
      return t * t
    },
    // decelerating to zero velocity
    easeOutQuad(t) {
      return t * (2 - t)
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
    },
    // accelerating from zero velocity
    easeInCubic(t) {
      return t * t * t
    },
    // decelerating to zero velocity
    easeOutCubic(t) {
      return --t * t * t + 1
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
    },
    // accelerating from zero velocity
    easeInQuart(t) {
      return t * t * t * t
    },
    // decelerating to zero velocity
    easeOutQuart(t) {
      return 1 - --t * t * t * t
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
    },
    // accelerating from zero velocity
    easeInQuint(t) {
      return t * t * t * t * t
    },
    // decelerating to zero velocity
    easeOutQuint(t) {
      return 1 + --t * t * t * t * t
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint(t) {
      return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
    },
  }
  // window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘(刷新)之前执行
  // 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。
  // 换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。
  // requestAnimationFrame()的兼容性封装：先判断是否原生支持各种带前缀的
  // 不行的话就采用延时的方案
  ;(function() {
    let lastTime = 0
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
          let currentTime = new Date().getTime()
          // 16.7ms是1000/60,每一帧需要的毫秒数
          // currentTime - lastTime是两次window.requestAnimationFrame执行的间隔时间
          // 16.7 - (currentTime - lastTime)估计是想让setTimeoutm每执行完回调函数callback刚好到达16.7ms
          // 即在完成callback后刚好一帧结束
          let timeToCall = Math.max(0, 16.7 - (currentTime - lastTime))
          let timer = window.setTimeout(function() {
            callback(currentTime + timeTocall)
          }, timeToCall)
          lastTime = currentTime + timeToCall
          return timer
        }
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
        window.webkitCancelRequestAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.mozCancelRequestAnimationFrame ||
        window.msCancelAnimationFrame ||
        window.msCancelRequestAnimationFrame ||
        window.oCancelAnimationFrame ||
        window.oCancelRequestAnimationFrame ||
        function(id) {
          window.clearTimeout(id)
        }
    }
  })()

  let element = checkElement()
  let start = element.scrollTop // 当前y轴滚动距离
  // Date.now()和new Date().getTime()一样，获取毫秒级时间戳
  // new Date().getTime()兼容性更好
  let startTime = new Date().getTime() // 当前时间

  function scroll() {
    let nowTime = new Date().getTime()
    let time = Math.min(1, (nowTime - startTime) / duration)
    let timeFunction = easings[easing](time)
    element.scrollTop = timeFunction * (destination - start) + start
    if (element.scrollTop === destination) {
      callback && callback() // 回调函数
      return
    }
    window.requestAnimationFrame(scroll)
  }
  scroll()
}

function checkElement() {
  // chrome,safari及一些浏览器对于documentElement的计算标准化
  // 旧版本的chrome,safari及一些浏览器documentElement.scrollTop为undefined
  // 新版本的的chrome,safari的documentElement.scrollTop是有效的，而document.body.scrollTop是固定值0
  let element = document.documentElement.scrollTop
    ? document.documentElement
    : document.body
  return element
}
```

### 触底加载

```js
// 触底的条件：scrollTop + clientHeight >= scrollHeight
//获取页面滚动的距离(被卷去的高)
let scrollTop =
  window.pageYOffset ||
  document.documentElement.scrollTop ||
  document.body.scrollTop

// 获取页面网页可见区域高(不包含边框)
let clientHeight =
  document.documentElement.clientHeight || document.body.clientHeight

// 获取网页全文高（包括被卷去的部分）
let scrollHeight =
  document.documentElement.scrollHeight || document.body.scrollHeight
window.addEventListener(function () {
  if (scrollTop + clientHeight >= scrollHeight) {
    // do something...
  }
})
```



### 文件上传

https://juejin.cn/post/6844903968338870285#heading-17

#### form 表单上传（不推荐）

需要把 form 标签的`enctype`设置为`multipart/form-data`，同时`method`必须为`post`方法。

这种方式上传文件，不需要 js ，而且没有兼容问题，所有浏览器都支持，就是体验很差，**导致页面刷新，页面其他数据丢失**。

```html
<form method="post" action="http://localhost:8100" enctype="multipart/form-data"></form>
```

#### 多文件上传

##### input 标签 type="file"

- accept：规定文件类型，参阅 [IANA MIME 类型](http://www.iana.org/assignments/media-types/)，获得标准 MIME 类型的完整列表

- multiple：允许上传多个文件

```html
<input id="f1" type="file" multiple />
```

##### 请求头 Content-Type

需要在表单中进行文件上传时，就需要使用该格式

```js
headers: {
	'Content-Type': 'multipart/form-data;charset=UTF-8'
}
```

**HTML**

```HTML
<div class="addFiles">
  <input id="f1" type="file" multiple />
</div>
<button id="submit">提交</button>
```

**JS**

```js
let fileMaxCount = 3
let willUploadFile = []
let f1 = document.getElementById('f1')
f1.addEventListener('change', function (e) {
  // fileList 是  FileList对象，其成员是 File 对象
  // 一个 FileList 对象通常来自于一个 HTML <input> 元素的 files 属性
  let fileList = this.files
  if (
    willUploadFile.length > fileMaxCount ||
    fileList.length > fileMaxCount ||
    willUploadFile.length + fileList.length > fileMaxCount
  ) {
    alert('最多只能上传' + fileMaxCount + '个文件')
    return
  }
  // 生成 fileList.length 个块级元素用来显示文件
  for (let i = 0; i < fileList.length; i++) {
    let fileBox = document.createElement('div')
    let fileName = document.createElement('span')
    // 这里为了方便就写了 progress 标签，实际上还是用div实现
    let progress = document.createElement('progress')
    let removeBtn = document.createElement('button')
    // 如果是图片，则可以加上预览功能
    // let img = document.createElement('img')
    // img.src = window.URL.createObjectURL(fileList[i])
    // img.onload = function () {
    //   // 释放内存
    //   window.URL.revokeObjectURL(this.src)
    // }
    fileBox.className = 'fileBox'
    fileName.innerHTML = `<span>${fileList[i].name}</span>`
    removeBtn.innerText = '删除文件'
    removeBtn.addEventListener('click', function () {
      fileBox.remove()
    })
    // fileBox.append(img)
    fileBox.append(fileName)
    fileBox.append(progress)
    fileBox.append(removeBtn)
    document.querySelector('.addFiles').append(fileBox)
    // FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去
    let form = new FormData()
    // 向 FormData 中添加新的属性值，FormData 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值。
    // upload 是与后台约定好的
    form.append('upload', fileList[i])
    willUploadFile.push({
      form,
      progress,
    })
  }
})

// 提交文件请求
function filePost({ url, form, progress }) {
  axios
    .post(url, form, {
      // 需要在表单中进行文件上传时，就需要使用该格式
      headers: {
        'Content-Type': 'multipart/form-data;charset=UTF-8',
      },
      onUploadProgress: event => {
        // 进度条变化
        let complete = ((event.loaded / event.total) * 100).toFixed(2)
        progress.style.width = complete + ' %'
      },
    })
    .catch(e => {
      // 提示上传失败
    })
}

// 文件上传
function sumbit(files) {
  if (files.length === 0) {
    return
  }
  files.forEach(item => {
    filePost({
      url: 'xxx',
      form: item.form,
      progress: item.progress,
    })
  })
}

// 点击提交
document.querySelector('#submit').addEventListener('click', function () {
  sumbit(willUploadFile)
})
```

#### 文件切片

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件
- 服务端保存各段文件
- 浏览器端所有分片上传完成，发送给服务端一个合并文件的请求
- 服务端根据文件标识、类型、各分片顺序进行文件合并

> 每个chunk的上传进度乘以 （chunk.size / file.size），然后将每个chunk的上传进度相加才是总上传进度

```js
// 提交时才对文件切片
function submitUpload() {
  let chunkSize = 2 * 1024 * 1024 // 分割大小，2m
  let file = document.getElementById('f1').files[0]
  // 存储分割块
  let chunks = [],
    token = +new Date(),
    name = file.name,
    chunkCount = 0,
    sendChunkCount = 0

  if (!file) {
    alert('请选择文件')
    return
  }

  //拆分文件
  if (file.size > chunkSize) {
    //拆分文件
    let start = 0,
      end = 0
    while (true) {
      end += chunkSize
      // [start,end)
      let blob = file.slice(start, end)
      console.log()
      start += chunkSize

      if (!blob.size) {
        //拆分结束
        break
      }

      chunks.push(blob)
    }
  } else {
    chunks.push(file.slice(0))
  }

  console.log(chunks)

  chunkCount = chunks.length

  //没有做并发限制，较大文件导致并发过多，tcp 链接被占光 ，需要做下并发控制，比如只有4个在请求在发送
  for (let i = 0; i < chunkCount; i++) {
    let fd = new FormData() //构造FormData对象
    fd.append('token', token)
    fd.append('f1', chunks[i])
    fd.append('index', i)
    xhrSend(fd, function () {
      sendChunkCount += 1
      if (sendChunkCount === chunkCount) {
        console.log('上传完成，发送合并请求')

        let formD = new FormData()
        formD.append('type', 'merge')
        formD.append('token', token)
        formD.append('chunkCount', chunkCount)
        formD.append('filename', name)
        xhrSend(formD)
      }
    })
  }
}

function xhrSend(fd, cb) {
  let xhr = new XMLHttpRequest() //创建对象
  xhr.open('POST', 'http://localhost:8100/', true)

  xhr.onreadystatechange = function () {
    console.log('state change', xhr.readyState)
    if (xhr.readyState == 4 && xhr.status == 200) {
      console.log(xhr.responseText)
      cb && cb()
    }
  }
}
```

#### 文件断点上传

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件
- 为每个分段生成 hash 值，使用 `spark-md5` 库
- 将上传成功的分段信息保存到本地 / 服务器端
- 重新上传时，进行和本地分段 hash 值的对比，如果相同的话则跳过，继续下一个分段的上传



**基于 HTTP Range 实现文件分片并发下载**

https://mp.weixin.qq.com/s/J55UtidL_WI0zSJM1C7kXQ



#### 下载

`a`标签可以访问下载文件的地址，浏览器帮助进行下载。但是对于浏览器支持直接浏览的txt、png、jpg、gif等文件，是不提供直接下载（可右击从菜单里另存为）的。

为了解决这个直接浏览不下载的问题，可以利用`download`属性。

但只支持下载**同源**下载链接。

如果你尝试下载跨域链接，那么其实`download`的效果就会没了，跟不设置`download`表现一致。即浏览器能预览的还是会预览，而不是下载。

```js
function downloadFile(url, fileName) {
  const link = document.createElement('a')
  link.style.display = 'none'
  link.href = url
  link.download = fileName
  document.body.append(link)
  link.click()
  document.body.removeChild(link)
}

```

> 浏览器处于安全考虑，下载文件保存路径只能在浏览器中设置，或者设置成每次都询问，不能由js代码指定

### ASE加密

```ts
import cryptoJs from 'crypto-js';

// s：要加密的字符串
// salt：盐
export function AES(s: string, salt: string = '默认值') {
  const keys = cryptoJs.enc.Utf8.parse(salt);
  const params = cryptoJs.enc.Utf8.parse(s);
  // 开始加密
  const encryptorStr = cryptoJs.AES.encrypt(params, keys, {
    mode: cryptoJs.mode.ECB,
    padding: cryptoJs.pad.Pkcs7,
  });
  // 返回加密后的转换成 字符串
  return String(encryptorStr);
}

```

### token登录

最近公司在改造接口的请求的验证，之前是登陆后返回一个**token**,在请求的时候动态添加到**header**中，以此来验证身份，当返回**401**直接去重新登录；现在登录返回**token**和**refreshToken**两个参数，拿**token**去添加**header**,当返回**401**时并不直接去登录而是拿**refreshToken**去请求一个接口，刷新得到新的**token**和**refreshToken**，拿到新的**token**再去请求当前返回**401**的接口，如果此时返回**401**则是真正的过期才需要去登录。

#### 解决多次刷新token问题

https://juejin.cn/post/6896682955209441287

```js
finally{
	this.isReflash = false
}
```

### 单点登录

iframe + postMessage + localStorage

处理步骤
1、登录主系统，获取各个子系统的token；
2、点击项目地址链接后，创建一个隐藏iframe并使用postMessage将token传递过去，iframe接收后将token存到iframe所对应的域名下的localStorage；
3、通过window.open(url, ‘_blank’)打开一个新地址；
4、移除该iframe。

```js
// 创建iframe存储localStorage
var iframe = document.createElement('iframe')
iframe.setAttribute(
  'style',
  'position:absolute;width:0px;height:0px;left:-500px;top:-500px;'
)
iframe.src = addr
document.body.append(iframe)
// 传递token给加载完成后的iframe
iframe.onload = () => {
  iframe.contentWindow.postMessage(
    {
      token: this.tokenMap[key]
    },
    `${addr}`
  )
  setTimeout(function () {
    iframe.remove()
    iframe = null
  }, 5000)
  setTimeout(function () {
    window.open(addr, '_blank')
  }, 0)
}

```



### easings 缓动函数

 https://zhuanlan.zhihu.com/p/25676357

 https://www.cnblogs.com/byit/p/4535971.html

###### 基本原理介绍

假设一个运动中的物体，处于跑道的100米处，准备向250米处前进，计划运动时间2秒。我们从0秒开始计时，那么随着时间的推移，它所处的位置和当前时间的关系可以用如下函数（公式）表示：

```js
function linear(time, begin, change, duration) {
    return change * (time / duration) + begin;
}
```

各个参数的意思为：

- time：当前已经运动的时间，当前时间 - 开始时间，变量
- begin：距离的初始值（距离原点0米的初始值），即100（米），常量
- change：目标值与初始值的差值，即250 - 100 = 150（米），常量
- duration：运动时长，即2（秒），常量

这个公式的原理是，把已经运动的时长除以运动总时长，算出当前的时间进度（百分比），再将百分比乘以总距离换算成目前已经运动的距离，最后加上初始值得到最终运动进度。

那么当物体开始运动，即0秒时，根据公式物体还处于原地：150 * (0 / 2) + 100 = 100; 当物体运动了1秒之后，物体此时的位置为：150 * (1 / 2) + 100 = 175。恰好在起点和终点的中间位置 当物体运动了2秒之后，物体的位置为：150 * (2 / 2) + 100 = 250。恰好是终点位置。

以上是小学四年级的数学内容，相信各位都能掌握，没毛病。

我们再把这个公式抽象一下，假如把change函数设为1，begin值设为0，那么得到的函数会是如下所示：

```js
function linear(time, duration) {
    return time/duration;
}
```

很明显这个函数返回值只会处于0到1之间。我们把这个函数的返回值当作“系数”，对于任意给定起点值和终点值，我们都能根据上面描述的原理，利用这个系数算出任意时刻的进度或者说是运动状态。最初的公式我们可以拆分为以下两个函数：

```js
function factor(time, duration) {
    return time/duration;
}

function progress(time, begin, end, duration) {
    return begin + (end - begin) * factor(time, duration);
}
```

根据上述公式，时间进度和移动进度的关系图如下图所示（横向为时间，纵向为位移）：

![img](https://pic4.zhimg.com/80/v2-2790134429f8c8a263dea12272aa346b_720w.png)

没错，是一条直线。CSS中transition-timing-function属性的可选值linear就是这个意思：随着时间的推移，值变化是平均的。

###### 系数的秘密

然而缓动效果除了linear以外，还有ease-in，ease-out，ease-in-out等等。所有这些特效的奥秘都在于上一小节所说的“系数”里。

在linear特效中，系数的产生是线性的:time / duration。如果我们把系数公式改为Math.pow(time / duration, 2)，而progress函数不变。则时间和位移的坐标图趋势则会变得如下图所示：

![img](https://pic3.zhimg.com/80/v2-e12917881a1318f89186a786bfa3971a_720w.png)

没错，正如图的标题所示，这就变成了ease-in的缓动特效。物体的运动状况与纵坐标相同，由慢逐渐加快。

我们可以继续把系数公式抽象，继续改变Math.pow(time / duration, 2)中的平方系数2，改为3、4甚至5。借助可视化函数工具[mathway](https://link.zhihu.com/?target=http%3A//www.mathway.com/Graph)，我们可以把x^2, x^3, x^4，x^5的坐标图分别绘制出来：

![img](https://pic4.zhimg.com/80/v2-d724c14d7198b2184f7556c3258d9c0b_720w.png)

如果你对这几个图片感到眼熟的话那就没错了，因为这四个函数分别对应于以下四种缓动效果：

![img](https://pic1.zhimg.com/80/v2-483af2582bc5ea92b8892da14fc14578_720w.png)

注意这四种缓动效果的名称，虽然前面都是以ease-in开头，但后缀都不相同。后缀分别是Quad, Cubic, Quart, Quint。ease-in缓动效果虽说总体上是加速效果，但在此基础上四种后缀代表了四种加速的激烈程度，激烈程度由低到高：Quad最接近平缓（接近线性），Quint变化最为剧烈。四个后缀分别就对应了Math.pow函数的第二个参数次方系数。Quint等于2，Cubic等于3，Quart等于4，Quint等于5。

**在这里我可以给出你一个结论了，缓动效果其实就是关于运行时间（进度）的函数。**

你可能会纳闷，上面的位移函数progress不是和起始值和终点值相关吗？难道factor函数就决定了一切？

我凭借着我对高中数学的记忆，针对数学函数做一个解释（如果有误请见谅请纠正我:P）：例数学函数y = x^2为例，下面列举了其他与它相似的三个函数进行对比：

![img](https://pic2.zhimg.com/80/v2-465df67f3baa1fe515ee64ee7ead3a61_720w.png)



- 左一和左二图对比，相差的只是纵坐标的位移，图中曲线趋势完全一致
- 左二和左三图对比，不同的是平方项前的系数，影响的是曲线的“开口大小”
- 左三和左四图对比，不同的是次方数，此时曲线的“形状”已经完全改变。

而缓动效果最大的差异，在于曲线的“形状”不同。所以真正起作用的只会是进度函数factor。

除了Quad，Cubic，Quart，Quint外，还有其它级别的缓动程度，比如Expo，Back，Bounce等，不同之处也仅仅在于函数中处理进度的方式不同。更多的视觉效果可以参考[easings.net](https://link.zhihu.com/?target=http%3A//easings.net/zh-cn)。

除了ease-in以外的缓动效果的脚本实现可以参考[easing.js](https://link.zhihu.com/?target=https%3A//gist.github.com/gre/1650294)。这个类库中的实现与本文讲解的稍稍不同是，它直接将“进度”作为函数参数，例如：

```text
linear: function (t) { return t },
easeInQuad: function (t) { return t*t },
easeInCubic: function (t) { return t*t*t },
```

当然CSS中还允许通过贝塞尔曲线来制定缓动效果，曲线如下图所示

![img](https://pic1.zhimg.com/80/v2-76775dd18efc6e29d3639bbf1b7e6a4c_720w.png)

通过控制P2点和P1点的位置来控制曲线的变化，在CSS中则传入P1和P2点的位置即可

```text
transition-timing-function: cubic-bezier(P1.x, P1.y, P2.x, P2.y);
```

你能通过[贝塞尔曲线编辑器](https://link.zhihu.com/?target=http%3A//greweb.me/bezier-easing-editor/example/)来编辑曲线。

###### 函数及图像

![clipboard.png](https://segmentfault.com/img/bV6ACd?w=751&h=533)

```js
// 公式一：
var Tween = {
    Linear: function(t, b, c, d) {
        return c * t / d + b;
    },
    Quad: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        easeOut: function(t, b, c, d) {
            return - c * (t /= d) * (t - 2) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t + b;
            return - c / 2 * ((--t) * (t - 2) - 1) + b;
        }
    },
    Cubic: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        easeOut: function(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        }
    },
    Quart: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },
        easeOut: function(t, b, c, d) {
            return - c * ((t = t / d - 1) * t * t * t - 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;
            return - c / 2 * ((t -= 2) * t * t * t - 2) + b;
        }
    },
    Quint: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        easeOut: function(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        }
    },
    Sine: {
        easeIn: function(t, b, c, d) {
            return - c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },
        easeOut: function(t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        easeInOut: function(t, b, c, d) {
            return - c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        }
    },
    Expo: {
        easeIn: function(t, b, c, d) {
            return (t == 0) ? b: c * Math.pow(2, 10 * (t / d - 1)) + b;
        },
        easeOut: function(t, b, c, d) {
            return (t == d) ? b + c: c * ( - Math.pow(2, -10 * t / d) + 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if (t == 0) return b;
            if (t == d) return b + c;
            if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
            return c / 2 * ( - Math.pow(2, -10 * --t) + 2) + b;
        }
    },
    Circ: {
        easeIn: function(t, b, c, d) {
            return - c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },
        easeOut: function(t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return - c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
    },
    Elastic: {
        easeIn: function(t, b, c, d, a, p) {
            if (t == 0) return b;
            if ((t /= d) == 1) return b + c;
            if (!p) p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return - (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        easeOut: function(t, b, c, d, a, p) {
            if (t == 0) return b;
            if ((t /= d) == 1) return b + c;
            if (!p) p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        easeInOut: function(t, b, c, d, a, p) {
            if (t == 0) return b;
            if ((t /= d / 2) == 2) return b + c;
            if (!p) p = d * (.3 * 1.5);
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            if (t < 1) return - .5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
        }
    },
    Back: {
        easeIn: function(t, b, c, d, s) {
            if (s == undefined) s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        easeOut: function(t, b, c, d, s) {
            if (s == undefined) s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        easeInOut: function(t, b, c, d, s) {
            if (s == undefined) s = 1.70158;
            if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        }
    },
    Bounce: {
        easeIn: function(t, b, c, d) {
            return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;
        },
        easeOut: function(t, b, c, d) {
            if ((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            } else if (t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            } else if (t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            } else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
            }
        },
        easeInOut: function(t, b, c, d) {
            if (t < d / 2) return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;
            else return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        }
    }
}

// 公式二：

var tween = {
    easeInQuad: function(pos) {
        return Math.pow(pos, 2);
    },
    easeOutQuad: function(pos) {
        return - (Math.pow((pos - 1), 2) - 1);
    },
    easeInOutQuad: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 2);
        return - 0.5 * ((pos -= 2) * pos - 2);
    },
    easeInCubic: function(pos) {
        return Math.pow(pos, 3);
    },
    easeOutCubic: function(pos) {
        return (Math.pow((pos - 1), 3) + 1);
    },
    easeInOutCubic: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 3);
        return 0.5 * (Math.pow((pos - 2), 3) + 2);
    },
    easeInQuart: function(pos) {
        return Math.pow(pos, 4);
    },
    easeOutQuart: function(pos) {
        return - (Math.pow((pos - 1), 4) - 1)
    },
    easeInOutQuart: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
        return - 0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
    },
    easeInQuint: function(pos) {
        return Math.pow(pos, 5);
    },
    easeOutQuint: function(pos) {
        return (Math.pow((pos - 1), 5) + 1);
    },
    easeInOutQuint: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 5);
        return 0.5 * (Math.pow((pos - 2), 5) + 2);
    },
    easeInSine: function(pos) {
        return - Math.cos(pos * (Math.PI / 2)) + 1;
    },
    easeOutSine: function(pos) {
        return Math.sin(pos * (Math.PI / 2));
    },
    easeInOutSine: function(pos) {
        return ( - .5 * (Math.cos(Math.PI * pos) - 1));
    },
    easeInExpo: function(pos) {
        return (pos == 0) ? 0 : Math.pow(2, 10 * (pos - 1));
    },
    easeOutExpo: function(pos) {
        return (pos == 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
    },
    easeInOutExpo: function(pos) {
        if (pos == 0) return 0;
        if (pos == 1) return 1;
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(2, 10 * (pos - 1));
        return 0.5 * ( - Math.pow(2, -10 * --pos) + 2);
    },
    easeInCirc: function(pos) {
        return - (Math.sqrt(1 - (pos * pos)) - 1);
    },
    easeOutCirc: function(pos) {
        return Math.sqrt(1 - Math.pow((pos - 1), 2))
    },
    easeInOutCirc: function(pos) {
        if ((pos /= 0.5) < 1) return - 0.5 * (Math.sqrt(1 - pos * pos) - 1);
        return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
    },
    easeOutBounce: function(pos) {
        if ((pos) < (1 / 2.75)) {
            return (7.5625 * pos * pos);
        } else if (pos < (2 / 2.75)) {
            return (7.5625 * (pos -= (1.5 / 2.75)) * pos + .75);
        } else if (pos < (2.5 / 2.75)) {
            return (7.5625 * (pos -= (2.25 / 2.75)) * pos + .9375);
        } else {
            return (7.5625 * (pos -= (2.625 / 2.75)) * pos + .984375);
        }
    },
    easeInBack: function(pos) {
        var s = 1.70158;
        return (pos) * pos * ((s + 1) * pos - s);
    },
    easeOutBack: function(pos) {
        var s = 1.70158;
        return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
    },
    easeInOutBack: function(pos) {
        var s = 1.70158;
        if ((pos /= 0.5) < 1) return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));
        return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },
    elastic: function(pos) {
        return - 1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
    },
    swingFromTo: function(pos) {
        var s = 1.70158;
        return ((pos /= 0.5) < 1) ? 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },
    swingFrom: function(pos) {
        var s = 1.70158;
        return pos * pos * ((s + 1) * pos - s);
    },
    swingTo: function(pos) {
        var s = 1.70158;
        return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
    },
    bounce: function(pos) {
        if (pos < (1 / 2.75)) {
            return (7.5625 * pos * pos);
        } else if (pos < (2 / 2.75)) {
            return (7.5625 * (pos -= (1.5 / 2.75)) * pos + .75);
        } else if (pos < (2.5 / 2.75)) {
            return (7.5625 * (pos -= (2.25 / 2.75)) * pos + .9375);
        } else {
            return (7.5625 * (pos -= (2.625 / 2.75)) * pos + .984375);
        }
    },
    bouncePast: function(pos) {
        if (pos < (1 / 2.75)) {
            return (7.5625 * pos * pos);
        } else if (pos < (2 / 2.75)) {
            return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + .75);
        } else if (pos < (2.5 / 2.75)) {
            return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + .9375);
        } else {
            return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + .984375);
        }
    },
    easeFromTo: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
        return - 0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
    },
    easeFrom: function(pos) {
        return Math.pow(pos, 4);
    },
    easeTo: function(pos) {
        return Math.pow(pos, 0.25);
    },
    linear: function(pos) {
        return pos
    },
    sinusoidal: function(pos) {
        return ( - Math.cos(pos * Math.PI) / 2) + 0.5;
    },
    reverse: function(pos) {
        return 1 - pos;
    },
    mirror: function(pos, transition) {
        transition = transition || tween.sinusoidal;
        if (pos < 0.5) return transition(pos * 2);
        else return transition(1 - (pos - 0.5) * 2);
    },
    flicker: function(pos) {
        var pos = pos + (Math.random() - 0.5) / 5;
        return tween.sinusoidal(pos < 0 ? 0 : pos > 1 ? 1 : pos);
    },
    wobble: function(pos) {
        return ( - Math.cos(pos * Math.PI * (9 * pos)) / 2) + 0.5;
    },
    pulse: function(pos, pulses) {
        return ( - Math.cos((pos * ((pulses || 5) - .5) * 2) * Math.PI) / 2) + .5;
    },
    blink: function(pos, blinks) {
        return Math.round(pos * (blinks || 5)) % 2;
    },
    spring: function(pos) {
        return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp( - pos * 6));
    },
    none: function(pos) {
        return 0
    },
    full: function(pos) {
        return 1
    }
}
```

### 千分位

```js
let value = 1213321
value = (value + '').replace(/\B(?=(\d{3})+(?!\d))/g, ',')
console.log(value)
```

### EventEmitter

```ts
type Callback = (...args: any[]) => void;
interface Subscriptions {
  [key: string]: {
    [key: string]: Callback;
  };
}
// 简单地模仿uuid
const uuid = () => Math.random();

class EventEmitter {
  private subscriptions: Subscriptions = {};

  on(eventName: string, callback: Callback) {
    const id = '' + uuid();
    if (this.subscriptions[eventName]) {
      this.subscriptions[eventName][id] = callback;
    } else {
      this.subscriptions[eventName] = { [id]: callback };
    }
    return id;
  }

  emit(eventName: string, args?: any[]) {
    if (this.subscriptions[eventName]) {
      const cbs = Object.values(this.subscriptions[eventName]);
      for (const cb of cbs) {
        cb(...(args || []));
      }
    }
  }

  off(id: string) {
    for (let eventName in this.subscriptions) {
      if (eventName[id]) {
        delete eventName[id];
        break;
      }
    }
  }
}

export default new EventEmitter()
```



### Authorization popup window

https://help.aliyun.com/document_detail/175896.html

https://github.com/XD2Sketch/react-oauth-popup/blob/master/src/index.tsx

**postMessage**

```typescript
type ShowAuthWindowOptions = {
  path: string;
  callback: (props: { code: string | null; }) => void;
  windowName?: string;
  windowFeatures?: string;
};

//Authorization popup window code
function ShowAuthWindow(options: ShowAuthWindowOptions) {
    const {
      path,
      callback,
      windowName = 'ConnectWithOAuth',
      windowFeatures = `
      location=0,
      status=0,
      left=${(window.screenLeft ?? window.screenX) + window.outerWidth / 2 - 400},
      top=${(window.screenTop ?? window.screenY) + window.outerHeight / 2 - 300},
      width=800,
      height=600,
      noopener
      `
    } = options;
    
    const oauthWindow = window.open(path, windowName, windowFeatures);
    
    return oauthWindow
}

const oauthWindow = ShowAuthWindow({path:""})
oauthWindow?.focus();

function handleMessage(e){
  if(e.data.code){
    // get access_token via code
    window.removeEventListener("message", handleMessgae)
    oauthWindow.close()
  }
}

window.addEventListener("message", handleMessage)

// html
<script>
    const sch = new URL(location.href).searchParams
    const code = sch.get('code')
    if(code){
      window.opener.postMessage({authCode}, location.origin + location.pathname)
    }
</script>
```



**setInterval (deprecated)**

throw error: cors

```typescript
type ShowAuthWindowOptions = {
  path: string;
  callback: (props: { code: string | null; }) => void;
  windowName?: string;
  windowFeatures?: string;
};

//Authorization popup window code
function ShowAuthWindow(options: ShowAuthWindowOptions) {
  const {
    path,
    callback,
    windowName = 'ConnectWithOAuth',
    windowFeatures = `
    location=0,
    status=0,
    left=${window.screenLeft + window.outerWidth / 2 - 400},
    top=${window.screenTop + window.outerHeight / 2 - 300},
    width=800,
    height=600
    `
  } = options;
  const oauthWindow = window.open(path, windowName, windowFeatures);
  oauthWindow?.focus();
  
  if (!oauthWindow)
    return;
  
  const start = +new Date();
  const timer = setInterval(() => {
    // expire after 5 min
    const isOver = (+new Date() - start) > 5 * 60 * 1000;
    const { search } = oauthWindow.window.location;
    const sch = new URLSearchParams(search.replace(/^\?/g, ''));
    // or const sch = new URL(location.href).searchParams
    const code = sch.get('code');
    if (code || oauthWindow.closed || isOver) {
      window.clearInterval(timer);
      callback?.({ code });
      oauthWindow.window.close();
    }
  }, 700);

  return timer;
}

// create new oAuth popup window and monitor it
ShowAuthWindow({
  path: "",
  callback: function (params) {
    if (params) {
      console.log('callback');
    }
  }
});
```



### 异步并发

**手写 p-limit，40 行代码实现并发控制**

https://mp.weixin.qq.com/s/TbtChYU9OL64MTcQhrA63w



```typescript
function limit(maxCount){
  // 任务队列
  let queue = []
  let activeCount = 0

  const next = ()=>{
    //下一个任务
    activeCount--
    if(queue.length>0){
      queue.shift()()
    }
  }
  const run = async (fn,resolve,args)=>{
    //执行一个函数
    activeCount++
    const result = (async()=>fn(...args))()
    resolve(result)
    await result
    next() //下一个
  }
  const push = async (fn,resolve,args)=>{
    queue.push(run.bind(null,fn,resolve,args))
    if(activeCount<maxCount && queue.length>0){
      // 队列没满 并且还有任务 启动任务
      queue.shift()()
    }
  }

  let runner = (fn,...args)=>{
    return new Promise((resolve)=>{
      push(fn,resolve,args)
    })
  }
  return runner
}
```

还可以用Promise来实现

```typescript
async function asyncPool({
  limit,
  items,
  fn
}) {
  const promises= []
  const pool = new Set()
  for (const item of items) {
    const promise = fn(item)
    promises.push(promise)
    pool.add(promise)
    const clean = () => pool.delete(promise)
    promise.then(clean, clean)
    if (pool.size >= limit) await Promise.race(pool)
  }
  return Promise.all(promises)
}
```



### 左补零

```typescript
function leftpad(str,length,ch){
  let len = length-str.length+1
  return Array(len).join(ch)+str
}
```

二分法+位运算的优化思路：

```typescript
function leftpad2(str,length,ch){
  let len = length-str.length
  total = ''
  while(true){
    // if(len%2==1){
    if(len & 1){
      total+=ch
    }
    if(len==1){
      return total+str
    }
    ch += ch
    len = len >> 1
    // len = parseInt(len/2)
  }
}
```

数据量越大，性能差距就越大，方式一需要创建一个大数组

```typescript
console.time('leftpad')
for(let i=0;i<10000;i++){
  leftpad('hello',1000,'0')
}
console.timeEnd('leftpad')

console.time('leftpad2')
for(let i=0;i<10000;i++){
  leftpad2('hello',1000,'0')
}
console.timeEnd('leftpad2')

❯ node leftpad.js
00000hello
00000hello
leftpad: 51.97ms
leftpad2: 2.077ms
```



### 获取 IP 地址

浏览器提供 WebRTC 功能，通过 UDP 协议建立连接，从而获取到公共 IP 地址、本地 IP 地址和媒体设备（如摄像头、麦克风）的数量及其哈希值。由于是通过 UDP 协议，所以即便是使用了代理，网站也能够获取到真实的公共和本地 IP 地址。

https://github.com/fingerprintjs/fingerprintjs



### binary string ArrayBuffer Blob  base64 string 的相互转换

![img](https://zhangkai.pro/ass/img/binary-data-in-javascript.png)

```javascript
const convert = {
  	// binary string
    binary: {
        toArrayBuffer(binaryString) {
          	// 与十六进制值 0xff 进行按位与运算，以确保结果只有一个字节（即低8位，符合 Uint8(0-255)的限制）
            return Uint8Array.from(binaryString, s => s.charCodeAt(0) & 0xff).buffer;
        },
        toBlob(binaryString, mimeType) {
            return new Blob([binaryString], { type: mimeType });
        },
        toBase64: binaryString => btoa(binaryString)
    },
    arrayBuffer: {
      	// toBinaryString
        toBinary(ab) {
            return String.fromCharCode.apply(null, new Uint8Array(ab));
        },
      	toString(ab){
          	return String.fromCharCode.apply(null, new Uint16Array(ab));
        },
        toBlob(ab, mimeType) {
            return new Blob([ab], { type: mimeType });
        },
        toBase64(ab) {
            return btoa(this.toBinary(ab));
        },
    },
    blob: {
        _readAsync(blob, mode) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(reader.result);
                reader.onerror = reject;
                reader[mode](blob);
            });
        },
        toBinaryAsync(blob) {
          	// readAsBinaryString 特性是非标准的，请尽量不要在生产环境中使用它
            // return this._readAsync(blob, 'readAsBinaryString');
          	return this._readAsync(blob, 'readAsArrayBuffer').then(ab => convert.arrayBuffer.toBinary(ab))
        },
        toArrayBufferAsync(blob) {
            return this._readAsync(blob, 'readAsArrayBuffer');
        },
        toBase64Async(blob) {
            return this._readAsync(blob, 'readAsDataURL').then(dataUri =>
                dataUri.replace(/data:[^;]+;base64,/, '')
            );
        }
    },
    base64: {
        toBinary: b64 => atob(b64),
        toArrayBuffer: b64 => convert.binary.toArrayBuffer(atob(b64)),
        toBlob: (b64, mimeType) => convert.binary.toBlob(atob(b64), mimeType)
    }
};

function str2ArrayBuffer(str) {
    const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char(utf-16)
  	// 当创建 TypedArray 子类（例如 Int8Array）的实例时，在内存的中会创建数组缓冲区，或者，如果将 ArrayBuffer 对象作为构造参数，则使用该 ArrayBuffer。缓冲区地址被保存为实例的内部属性并且所有的 TypedArray.prototype 方法都将基于数组缓冲区地址设置和获取值。
    const bufView = new Uint16Array(buf);
  
    for (var i=0, strLen=str.length; i < strLen; i++) {
    	bufView[i] = str.charCodeAt(i);
    }
  
    // or return bufView.buffer
    return buf;
}


function arrayBufferEqual(ab1, ab2) {
    if (ab1.byteLength !== ab2.byteLength) return false;
    const a1 = new Uint8Array(ab1);
    const a2 = new Uint8Array(ab2);
    for (let i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) return false;
    }
    return true;
}

(async function test() {
    const binary = 'ABC';
    const arrayBuffer = new Uint8Array([65, 66, 67]).buffer;
    const base64 = 'QUJD';

    console.assert(arrayBufferEqual(arrayBuffer, convert.binary.toArrayBuffer(binary)));
    console.assert(base64 === convert.binary.toBase64(binary));

    console.assert(binary === convert.arrayBuffer.toBinary(arrayBuffer));
    console.assert(base64 === convert.arrayBuffer.toBase64(arrayBuffer));

    console.assert(binary === convert.base64.toBinary(base64));
    console.assert(arrayBufferEqual(arrayBuffer, convert.base64.toArrayBuffer(base64)));

    const blobFromBinary = convert.binary.toBlob(binary, 'application/octet-stream');
    console.assert(arrayBufferEqual(arrayBuffer, await convert.blob.toArrayBufferAsync(blobFromBinary)));
    const blobFromArrayBuffer = convert.arrayBuffer.toBlob(arrayBuffer, 'application/octet-stream');
    console.assert(base64 === await convert.blob.toBase64Async(blobFromArrayBuffer));
    const blobFromBase64 = convert.base64.toBlob(base64, 'application/octet-stream');
    console.assert(binary === await convert.blob.toBinaryAsync(blobFromBase64));

    console.log('test done');
})();
```



### fetch progress

https://github.com/tq-bit/fetch-progress/tree/master

**client.js**

```javascript
export default function http(url, options, controller) {
  let loading = false;
	/** @type{Uint8Array[]} */
  let chunks = [];
  /** @type{string} */
  let results = null;

  const json = async () => {
    reset();
    loading = true;

    try {
      const response = await fetch(url, { signal: controller?.signal, ...options });

      if (response.status >= 200 && response.status < 300) {
        results = await _readBody(response);
        
        return JSON.parse(results)
      } else {
        throw new Error(response.statusText)
      }
    } catch (e) {
      reset();
      
      return Promise.reject(e);
    } finally {
      loading = false
    }
  }

  /**
   * @param {Response} response
   * @returns {Promise<string>}
   */
  const _readBody = async (response) => {
    const reader = response.body.getReader();
    // The length in decimal number of octets(八位字节)
    const length = +response.headers.get('content-length');
    let received = 0;

    try{
      // Loop through the response stream and extract data chunks
      while (loading) {
        // value: Uint8Array | undefined
        const { done, value } = await reader.read();
        const payload = { detail: { received, length, loading } };
        
        const onProgress = new CustomEvent('fetch-progress', payload);
        const onFinished = new CustomEvent('fetch-finished', payload)
  
        if (done) {
          // Finish loading
          loading = false;
          window.dispatchEvent(onFinished)
        } else {
          // Push values to the chunk array
          chunks.push(value);
          received += value.length;
          window.dispatchEvent(onProgress)
        }
      }
    } catch (e) {
      // maybe triggered by controller.abort
      return Promise.reject(e);
    }

    // Concat the chinks into a single array
    let body = new Uint8Array(received);
    let position = 0;

    // Order the chunks by their respective position
    for (let chunk of chunks) {
      body.set(chunk, position);
      position += chunk.length;
    }

    // Decode the response and return it
    return new TextDecoder('utf-8').decode(body);
  }

  const reset = () => {
    loading = false;
    chunks = [];
    results = null;
  }

  return await json();
}
```



**main.js**

```javascript
// Import the fetch client and initalize it
import http from './client.js';

// Grab the DOM elements
const progressbar = document.getElementById('progress-bar');
const progressbutton = document.getElementById('fetch-button');
const abortbutton = document.getElementById('abort-button');
const progresslabel = document.getElementById('progress-label');
let controller;

const setProgressbarValue = (payload) => {
  const { received, length, loading } = payload;
  const value = ((received / length) * 100).toFixed(2);
  progresslabel.textContent = `Download progress: ${value}%`;
  progressbar.value = value;
};

// Bind the fetch function to the button's click event
progressbutton.addEventListener('click', async () => {
  controller = new AbortController();
  const universities = await http('http://universities.hipolabs.com/search?country=United+States');
  controller = null;
  
  console.log(universities);
});

abortbutton.addEventListener('click', () => {
  controller.abort();
  alert('Request has been cancelled')
})

window.addEventListener('fetch-progress', (e) => {
  setProgressbarValue(e.detail);
});

window.addEventListener('fetch-finished', (e) => {
  setProgressbarValue(e.detail);
});
```



**index.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css">
    <title>Document</title>
    <style>
    	progress {
        width: 100%;
        height: 2rem;
        border-radius: 0;
        margin: 1rem 0;
      }

      progress[value]::-webkit-progress-value {
        background-color: steelblue;
      }

      button {
        width: 100%;
        color: #fff;
        border: none;
        padding: 0.5rem 1rem;
        font-size: 1rem;
        cursor: pointer;
        margin: 0.25rem 0;
      }

      #fetch-button {
        background-color: cornflowerblue;
      }

      #abort-button {
        background-color: coral;
      }

      .container {
        max-width: 35rem;
        margin: auto;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <label for="progress-bar" id="progress-label"> Download progress: </label>
      <progress id="progress-bar" value="0" min="0" max="100"></progress>
      <button id="fetch-button">Fetch</button>

      <button id="abort-button">Cancel request</button>
    </div>
    <script type="module" src="main.js"></script>
  </body>
</html>
```



