### 防抖和节流

#### 防抖 debounce

规定时间内多次触发事件，只执行最后一次。

适用场景：

- 按钮提交场景：防止多次点击提交
- 输入框：当输入最后一个字符才触发

```js
// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。
// immediate是否立即执行
function debounce(func, wait, immediate) {
  let timer;
  return function () {
    const args = arguments;
    if (timer) clearTimeout(timer);
    if (immediate) {
      const callNow = !timer;
      timer = setTimeout(function () {
        timer = null;
      }, wait)
      if (callNow) func.apply(this, args)
    } else {
      timer = setTimeout(function () {
        func.apply(this, args)
      }, wait);
    }
  }
}
```

#### 节流 throttle

规定时间内多次触发事件，只执行一次。

适用场景：

- 拖拽场景
- 缩放场景resize

```js
function throttle(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args)
      }, wait)
    }
  }
}
```

### 手写发布订阅

```ts
// 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储;

interface CacheProps {
  [key: string]: Array<(data?: any) => void>
}

class Observer {
  private caches: CacheProps = {} // 事件中心

  on(eventName: string, fn: (data?: any) => void) {
    // eventName事件名-独一无二, fn是订阅后执行的自定义行为
    this.caches[eventName] = this.caches[eventName] || []
    this.caches[eventName].push(fn)
  }

  emit(eventName: string, data?: any) {
    // 发布 => 将订阅的事件进行统一执行
    if (this.caches[eventName]) {
      this.caches[eventName].forEach((fn: (data?: any) => void) => fn(data))
    }
  }

  off(eventName: string, fn?: (data?: any) => void) {
    // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息
    if (this.caches[eventName]) {
      const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : []
      this.caches[eventName] = newCaches
    }
  }
}

```

### 返回顶部

```js
function scrollIt(
  destination = 0,
  duration = 200,
  easing = 'linear',
  callback,
) {
  // 曲线图解：https://www.jb51.net/article/86785.htm
  // t的取值为[0,1]
  let easings = {
    // no easing, no acceleration
    linear(t) {
      return t
    },
    // accelerating from zero velocity
    easeInQuad(t) {
      return t * t
    },
    // decelerating to zero velocity
    easeOutQuad(t) {
      return t * (2 - t)
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
    },
    // accelerating from zero velocity
    easeInCubic(t) {
      return t * t * t
    },
    // decelerating to zero velocity
    easeOutCubic(t) {
      return --t * t * t + 1
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
    },
    // accelerating from zero velocity
    easeInQuart(t) {
      return t * t * t * t
    },
    // decelerating to zero velocity
    easeOutQuart(t) {
      return 1 - --t * t * t * t
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
    },
    // accelerating from zero velocity
    easeInQuint(t) {
      return t * t * t * t * t
    },
    // decelerating to zero velocity
    easeOutQuint(t) {
      return 1 + --t * t * t * t * t
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint(t) {
      return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
    },
  }
  // window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘(刷新)之前执行
  // 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。
  // 换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。
  // requestAnimationFrame()的兼容性封装：先判断是否原生支持各种带前缀的
  // 不行的话就采用延时的方案
  ;(function() {
    let lastTime = 0
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
          let currentTime = new Date().getTime()
          // 16.7ms是1000/60,每一帧需要的毫秒数
          // currentTime - lastTime是两次window.requestAnimationFrame执行的间隔时间
          // 16.7 - (currentTime - lastTime)估计是想让setTimeoutm每执行完回调函数callback刚好到达16.7ms
          // 即在完成callback后刚好一帧结束
          let timeToCall = Math.max(0, 16.7 - (currentTime - lastTime))
          let timer = window.setTimeout(function() {
            callback(currentTime + timeTocall)
          }, timeToCall)
          lastTime = currentTime + timeToCall
          return timer
        }
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
        window.webkitCancelRequestAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.mozCancelRequestAnimationFrame ||
        window.msCancelAnimationFrame ||
        window.msCancelRequestAnimationFrame ||
        window.oCancelAnimationFrame ||
        window.oCancelRequestAnimationFrame ||
        function(id) {
          window.clearTimeout(id)
        }
    }
  })()

  let element = checkElement()
  let start = element.scrollTop // 当前y轴滚动距离
  // Date.now()和new Date().getTime()一样，获取毫秒级时间戳
  // new Date().getTime()兼容性更好
  let startTime = new Date().getTime() // 当前时间

  function scroll() {
    let nowTime = new Date().getTime()
    let time = Math.min(1, (nowTime - startTime) / duration)
    let timeFunction = easings[easing](time)
    element.scrollTop = timeFunction * (destination - start) + start
    if (element.scrollTop === destination) {
      callback && callback() // 回调函数
      return
    }
    window.requestAnimationFrame(scroll)
  }
  scroll()
}

function checkElement() {
  // chrome,safari及一些浏览器对于documentElement的计算标准化
  // 旧版本的chrome,safari及一些浏览器documentElement.scrollTop为undefined
  // 新版本的的chrome,safari的documentElement.scrollTop是有效的，而document.body.scrollTop是固定值0
  let element = document.documentElement.scrollTop
    ? document.documentElement
    : document.body
  return element
}
```

### 触底加载

```js
// 触底的条件：scrollTop + clientHeight >= scrollHeight
//获取页面滚动的距离(被卷去的高)
let scrollTop =
  window.pageYOffset ||
  document.documentElement.scrollTop ||
  document.body.scrollTop

// 获取页面网页可见区域高(不包含边框)
let clientHeight =
  document.documentElement.clientHeight || document.body.clientHeight

// 获取网页全文高（包括被卷去的部分）
let scrollHeight =
  document.documentElement.scrollHeight || document.body.scrollHeight
window.addEventListener(function () {
  if (scrollTop + clientHeight >= scrollHeight) {
    // do something...
  }
})
```



### 文件上传

https://juejin.cn/post/6844903968338870285#heading-17

#### form 表单上传（不推荐）

需要把 form 标签的`enctype`设置为`multipart/form-data`，同时`method`必须为`post`方法。

这种方式上传文件，不需要 js ，而且没有兼容问题，所有浏览器都支持，就是体验很差，**导致页面刷新，页面其他数据丢失**。

```html
<form method="post" action="http://localhost:8100" enctype="multipart/form-data"></form>
```

#### 多文件上传

##### input 标签 type="file"

- accept：规定文件类型，参阅 [IANA MIME 类型](http://www.iana.org/assignments/media-types/)，获得标准 MIME 类型的完整列表

- multiple：允许上传多个文件

```html
<input id="f1" type="file" multiple />
```

##### 请求头 Content-Type

需要在表单中进行文件上传时，就需要使用该格式

```js
headers: {
	'Content-Type': 'multipart/form-data;charset=UTF-8'
}
```

**HTML**

```HTML
<div class="addFiles">
  <input id="f1" type="file" multiple />
</div>
<button id="submit">提交</button>
```

**JS**

```js
let fileMaxCount = 3
let willUploadFile = []
let f1 = document.getElementById('f1')
f1.addEventListener('change', function (e) {
  // fileList 是  FileList对象，其成员是 File 对象
  // 一个 FileList 对象通常来自于一个 HTML <input> 元素的 files 属性
  let fileList = this.files
  if (
    willUploadFile.length > fileMaxCount ||
    fileList.length > fileMaxCount ||
    willUploadFile.length + fileList.length > fileMaxCount
  ) {
    alert('最多只能上传' + fileMaxCount + '个文件')
    return
  }
  // 生成 fileList.length 个块级元素用来显示文件
  for (let i = 0; i < fileList.length; i++) {
    let fileBox = document.createElement('div')
    let fileName = document.createElement('span')
    // 这里为了方便就写了 progress 标签，实际上还是用div实现
    let progress = document.createElement('progress')
    let removeBtn = document.createElement('button')
    // 如果是图片，则可以加上预览功能
    // let img = document.createElement('img')
    // img.src = window.URL.createObjectURL(fileList[i])
    // img.onload = function () {
    //   // 释放内存
    //   window.URL.revokeObjectURL(this.src)
    // }
    fileBox.className = 'fileBox'
    fileName.innerHTML = `<span>${fileList[i].name}</span>`
    removeBtn.innerText = '删除文件'
    removeBtn.addEventListener('click', function () {
      fileBox.remove()
    })
    // fileBox.append(img)
    fileBox.append(fileName)
    fileBox.append(progress)
    fileBox.append(removeBtn)
    document.querySelector('.addFiles').append(fileBox)
    // FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去
    let form = new FormData()
    // 向 FormData 中添加新的属性值，FormData 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值。
    // upload 是与后台约定好的
    form.append('upload', fileList[i])
    willUploadFile.push({
      form,
      progress,
    })
  }
})

// 提交文件请求
function filePost({ url, form, progress }) {
  axios
    .post(url, form, {
      // 需要在表单中进行文件上传时，就需要使用该格式
      headers: {
        'Content-Type': 'multipart/form-data;charset=UTF-8',
      },
      onUploadProgress: event => {
        // 进度条变化
        let complete = ((event.loaded / event.total) * 100).toFixed(2)
        progress.style.width = complete + ' %'
      },
    })
    .catch(e => {
      // 提示上传失败
    })
}

// 文件上传
function sumbit(files) {
  if (files.length === 0) {
    return
  }
  files.forEach(item => {
    filePost({
      url: 'xxx',
      form: item.form,
      progress: item.progress,
    })
  })
}

// 点击提交
document.querySelector('#submit').addEventListener('click', function () {
  sumbit(willUploadFile)
})
```

#### 文件切片

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件
- 服务端保存各段文件
- 浏览器端所有分片上传完成，发送给服务端一个合并文件的请求
- 服务端根据文件标识、类型、各分片顺序进行文件合并

> 每个chunk的上传进度乘以 （chunk.size / file.size），然后将每个chunk的上传进度相加才是总上传进度

```js
// 提交时才对文件切片
function submitUpload() {
  let chunkSize = 2 * 1024 * 1024 // 分割大小，2m
  let file = document.getElementById('f1').files[0]
  // 存储分割块
  let chunks = [],
    token = +new Date(),
    name = file.name,
    chunkCount = 0,
    sendChunkCount = 0

  if (!file) {
    alert('请选择文件')
    return
  }

  //拆分文件
  if (file.size > chunkSize) {
    //拆分文件
    let start = 0,
      end = 0
    while (true) {
      end += chunkSize
      // [start,end)
      let blob = file.slice(start, end)
      console.log()
      start += chunkSize

      if (!blob.size) {
        //拆分结束
        break
      }

      chunks.push(blob)
    }
  } else {
    chunks.push(file.slice(0))
  }

  console.log(chunks)

  chunkCount = chunks.length

  //没有做并发限制，较大文件导致并发过多，tcp 链接被占光 ，需要做下并发控制，比如只有4个在请求在发送
  for (let i = 0; i < chunkCount; i++) {
    let fd = new FormData() //构造FormData对象
    fd.append('token', token)
    fd.append('f1', chunks[i])
    fd.append('index', i)
    xhrSend(fd, function () {
      sendChunkCount += 1
      if (sendChunkCount === chunkCount) {
        console.log('上传完成，发送合并请求')

        let formD = new FormData()
        formD.append('type', 'merge')
        formD.append('token', token)
        formD.append('chunkCount', chunkCount)
        formD.append('filename', name)
        xhrSend(formD)
      }
    })
  }
}

function xhrSend(fd, cb) {
  let xhr = new XMLHttpRequest() //创建对象
  xhr.open('POST', 'http://localhost:8100/', true)

  xhr.onreadystatechange = function () {
    console.log('state change', xhr.readyState)
    if (xhr.readyState == 4 && xhr.status == 200) {
      console.log(xhr.responseText)
      cb && cb()
    }
  }
}
```

#### 文件断点上传

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件

- 为每个分段生成 hash 值，使用 `spark-md5` 库

- 将上传成功的分段信息保存到本地 / 服务器端

- 重新上传时，进行和本地分段 hash 值的对比，如果相同的话则跳过，继续下一个分段的上传

  

#### 下载

`a`标签可以访问下载文件的地址，浏览器帮助进行下载。但是对于浏览器支持直接浏览的txt、png、jpg、gif等文件，是不提供直接下载（可右击从菜单里另存为）的。

为了解决这个直接浏览不下载的问题，可以利用`download`属性。

但只支持下载**同源**下载链接。

如果你尝试下载跨域链接，那么其实`download`的效果就会没了，跟不设置`download`表现一致。即浏览器能预览的还是会预览，而不是下载。

```js
function downloadFile(url, fileName) {
  const link = document.createElement('a')
  link.style.display = 'none'
  link.href = url
  link.download = fileName
  document.body.append(link)
  link.click()
  document.body.removeChild(link)
}

```

> 浏览器处于安全考虑，下载文件保存路径只能在浏览器中设置，或者设置成每次都询问，不能由js代码指定

### ASE加密

```ts
import cryptoJs from 'crypto-js';

// s：要加密的字符串
// salt：盐
export function AES(s: string, salt: string = '默认值') {
  const keys = cryptoJs.enc.Utf8.parse(salt);
  const params = cryptoJs.enc.Utf8.parse(s);
  // 开始加密
  const encryptorStr = cryptoJs.AES.encrypt(params, keys, {
    mode: cryptoJs.mode.ECB,
    padding: cryptoJs.pad.Pkcs7,
  });
  // 返回加密后的转换成 字符串
  return String(encryptorStr);
}

```

### token登录

最近公司在改造接口的请求的验证，之前是登陆后返回一个**token**,在请求的时候动态添加到**header**中，以此来验证身份，当返回**401**直接去重新登录；现在登录返回**token**和**refreshToken**两个参数，拿**token**去添加**header**,当返回**401**时并不直接去登录而是拿**refreshToken**去请求一个接口，刷新得到新的**token**和**refreshToken**，拿到新的**token**再去请求当前返回**401**的接口，如果此时返回**410**则是真正的过期才需要去登录。

#### 解决多次刷新token问题

https://juejin.cn/post/6896682955209441287

```js
finally{
	this.isReflash = false
}
```

### easings 缓动函数

 https://zhuanlan.zhihu.com/p/25676357

 https://www.cnblogs.com/byit/p/4535971.html

###### 基本原理介绍

假设一个运动中的物体，处于跑道的100米处，准备向250米处前进，计划运动时间2秒。我们从0秒开始计时，那么随着时间的推移，它所处的位置和当前时间的关系可以用如下函数（公式）表示：

```js
function linear(time, begin, change, duration) {
    return change * (time / duration) + begin;
}
```

各个参数的意思为：

- time：当前已经运动的时间，当前时间 - 开始时间，变量
- begin：距离的初始值（距离原点0米的初始值），即100（米），常量
- change：目标值与初始值的差值，即250 - 100 = 150（米），常量
- duration：运动时长，即2（秒），常量

这个公式的原理是，把已经运动的时长除以运动总时长，算出当前的时间进度（百分比），再将百分比乘以总距离换算成目前已经运动的距离，最后加上初始值得到最终运动进度。

那么当物体开始运动，即0秒时，根据公式物体还处于原地：150 * (0 / 2) + 100 = 100; 当物体运动了1秒之后，物体此时的位置为：150 * (1 / 2) + 100 = 175。恰好在起点和终点的中间位置 当物体运动了2秒之后，物体的位置为：150 * (2 / 2) + 100 = 250。恰好是终点位置。

以上是小学四年级的数学内容，相信各位都能掌握，没毛病。

我们再把这个公式抽象一下，假如把change函数设为1，begin值设为0，那么得到的函数会是如下所示：

```js
function linear(time, duration) {
    return time/duration;
}
```

很明显这个函数返回值只会处于0到1之间。我们把这个函数的返回值当作“系数”，对于任意给定起点值和终点值，我们都能根据上面描述的原理，利用这个系数算出任意时刻的进度或者说是运动状态。最初的公式我们可以拆分为以下两个函数：

```js
function factor(time, duration) {
    return time/duration;
}

function progress(time, begin, end, duration) {
    return begin + (end - begin) * factor(time, duration);
}
```

根据上述公式，时间进度和移动进度的关系图如下图所示（横向为时间，纵向为位移）：

![img](https://pic4.zhimg.com/80/v2-2790134429f8c8a263dea12272aa346b_720w.png)

没错，是一条直线。CSS中transition-timing-function属性的可选值linear就是这个意思：随着时间的推移，值变化是平均的。

###### 系数的秘密

然而缓动效果除了linear以外，还有ease-in，ease-out，ease-in-out等等。所有这些特效的奥秘都在于上一小节所说的“系数”里。

在linear特效中，系数的产生是线性的:time / duration。如果我们把系数公式改为Math.pow(time / duration, 2)，而progress函数不变。则时间和位移的坐标图趋势则会变得如下图所示：

![img](https://pic3.zhimg.com/80/v2-e12917881a1318f89186a786bfa3971a_720w.png)

没错，正如图的标题所示，这就变成了ease-in的缓动特效。物体的运动状况与纵坐标相同，由慢逐渐加快。

我们可以继续把系数公式抽象，继续改变Math.pow(time / duration, 2)中的平方系数2，改为3、4甚至5。借助可视化函数工具[mathway](https://link.zhihu.com/?target=http%3A//www.mathway.com/Graph)，我们可以把x^2, x^3, x^4，x^5的坐标图分别绘制出来：

![img](https://pic4.zhimg.com/80/v2-d724c14d7198b2184f7556c3258d9c0b_720w.png)

如果你对这几个图片感到眼熟的话那就没错了，因为这四个函数分别对应于以下四种缓动效果：

![img](https://pic1.zhimg.com/80/v2-483af2582bc5ea92b8892da14fc14578_720w.png)

注意这四种缓动效果的名称，虽然前面都是以ease-in开头，但后缀都不相同。后缀分别是Quad, Cubic, Quart, Quint。ease-in缓动效果虽说总体上是加速效果，但在此基础上四种后缀代表了四种加速的激烈程度，激烈程度由低到高：Quad最接近平缓（接近线性），Quint变化最为剧烈。四个后缀分别就对应了Math.pow函数的第二个参数次方系数。Quint等于2，Cubic等于3，Quart等于4，Quint等于5。

**在这里我可以给出你一个结论了，缓动效果其实就是关于运行时间（进度）的函数。**

你可能会纳闷，上面的位移函数progress不是和起始值和终点值相关吗？难道factor函数就决定了一切？

我凭借着我对高中数学的记忆，针对数学函数做一个解释（如果有误请见谅请纠正我:P）：例数学函数y = x^2为例，下面列举了其他与它相似的三个函数进行对比：

![img](https://pic2.zhimg.com/80/v2-465df67f3baa1fe515ee64ee7ead3a61_720w.png)



- 左一和左二图对比，相差的只是纵坐标的位移，图中曲线趋势完全一致
- 左二和左三图对比，不同的是平方项前的系数，影响的是曲线的“开口大小”
- 左三和左四图对比，不同的是次方数，此时曲线的“形状”已经完全改变。

而缓动效果最大的差异，在于曲线的“形状”不同。所以真正起作用的只会是进度函数factor。

除了Quad，Cubic，Quart，Quint外，还有其它级别的缓动程度，比如Expo，Back，Bounce等，不同之处也仅仅在于函数中处理进度的方式不同。更多的视觉效果可以参考[easings.net](https://link.zhihu.com/?target=http%3A//easings.net/zh-cn)。

除了ease-in以外的缓动效果的脚本实现可以参考[easing.js](https://link.zhihu.com/?target=https%3A//gist.github.com/gre/1650294)。这个类库中的实现与本文讲解的稍稍不同是，它直接将“进度”作为函数参数，例如：

```text
linear: function (t) { return t },
easeInQuad: function (t) { return t*t },
easeInCubic: function (t) { return t*t*t },
```

当然CSS中还允许通过贝塞尔曲线来制定缓动效果，曲线如下图所示

![img](https://pic1.zhimg.com/80/v2-76775dd18efc6e29d3639bbf1b7e6a4c_720w.png)

通过控制P2点和P1点的位置来控制曲线的变化，在CSS中则传入P1和P2点的位置即可

```text
transition-timing-function: cubic-bezier(P1.x, P1.y, P2.x, P2.y);
```

你能通过[贝塞尔曲线编辑器](https://link.zhihu.com/?target=http%3A//greweb.me/bezier-easing-editor/example/)来编辑曲线。

###### 函数及图像

![clipboard.png](https://segmentfault.com/img/bV6ACd?w=751&h=533)

```js
// 公式一：
var Tween = {
    Linear: function(t, b, c, d) {
        return c * t / d + b;
    },
    Quad: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        easeOut: function(t, b, c, d) {
            return - c * (t /= d) * (t - 2) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t + b;
            return - c / 2 * ((--t) * (t - 2) - 1) + b;
        }
    },
    Cubic: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        easeOut: function(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        }
    },
    Quart: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },
        easeOut: function(t, b, c, d) {
            return - c * ((t = t / d - 1) * t * t * t - 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;
            return - c / 2 * ((t -= 2) * t * t * t - 2) + b;
        }
    },
    Quint: {
        easeIn: function(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        easeOut: function(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        }
    },
    Sine: {
        easeIn: function(t, b, c, d) {
            return - c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },
        easeOut: function(t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        easeInOut: function(t, b, c, d) {
            return - c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        }
    },
    Expo: {
        easeIn: function(t, b, c, d) {
            return (t == 0) ? b: c * Math.pow(2, 10 * (t / d - 1)) + b;
        },
        easeOut: function(t, b, c, d) {
            return (t == d) ? b + c: c * ( - Math.pow(2, -10 * t / d) + 1) + b;
        },
        easeInOut: function(t, b, c, d) {
            if (t == 0) return b;
            if (t == d) return b + c;
            if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
            return c / 2 * ( - Math.pow(2, -10 * --t) + 2) + b;
        }
    },
    Circ: {
        easeIn: function(t, b, c, d) {
            return - c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },
        easeOut: function(t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        easeInOut: function(t, b, c, d) {
            if ((t /= d / 2) < 1) return - c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
    },
    Elastic: {
        easeIn: function(t, b, c, d, a, p) {
            if (t == 0) return b;
            if ((t /= d) == 1) return b + c;
            if (!p) p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return - (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        easeOut: function(t, b, c, d, a, p) {
            if (t == 0) return b;
            if ((t /= d) == 1) return b + c;
            if (!p) p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        easeInOut: function(t, b, c, d, a, p) {
            if (t == 0) return b;
            if ((t /= d / 2) == 2) return b + c;
            if (!p) p = d * (.3 * 1.5);
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            } else var s = p / (2 * Math.PI) * Math.asin(c / a);
            if (t < 1) return - .5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
        }
    },
    Back: {
        easeIn: function(t, b, c, d, s) {
            if (s == undefined) s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        easeOut: function(t, b, c, d, s) {
            if (s == undefined) s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        easeInOut: function(t, b, c, d, s) {
            if (s == undefined) s = 1.70158;
            if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        }
    },
    Bounce: {
        easeIn: function(t, b, c, d) {
            return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;
        },
        easeOut: function(t, b, c, d) {
            if ((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            } else if (t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            } else if (t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            } else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
            }
        },
        easeInOut: function(t, b, c, d) {
            if (t < d / 2) return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;
            else return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        }
    }
}

// 公式二：

var tween = {
    easeInQuad: function(pos) {
        return Math.pow(pos, 2);
    },
    easeOutQuad: function(pos) {
        return - (Math.pow((pos - 1), 2) - 1);
    },
    easeInOutQuad: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 2);
        return - 0.5 * ((pos -= 2) * pos - 2);
    },
    easeInCubic: function(pos) {
        return Math.pow(pos, 3);
    },
    easeOutCubic: function(pos) {
        return (Math.pow((pos - 1), 3) + 1);
    },
    easeInOutCubic: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 3);
        return 0.5 * (Math.pow((pos - 2), 3) + 2);
    },
    easeInQuart: function(pos) {
        return Math.pow(pos, 4);
    },
    easeOutQuart: function(pos) {
        return - (Math.pow((pos - 1), 4) - 1)
    },
    easeInOutQuart: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
        return - 0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
    },
    easeInQuint: function(pos) {
        return Math.pow(pos, 5);
    },
    easeOutQuint: function(pos) {
        return (Math.pow((pos - 1), 5) + 1);
    },
    easeInOutQuint: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 5);
        return 0.5 * (Math.pow((pos - 2), 5) + 2);
    },
    easeInSine: function(pos) {
        return - Math.cos(pos * (Math.PI / 2)) + 1;
    },
    easeOutSine: function(pos) {
        return Math.sin(pos * (Math.PI / 2));
    },
    easeInOutSine: function(pos) {
        return ( - .5 * (Math.cos(Math.PI * pos) - 1));
    },
    easeInExpo: function(pos) {
        return (pos == 0) ? 0 : Math.pow(2, 10 * (pos - 1));
    },
    easeOutExpo: function(pos) {
        return (pos == 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
    },
    easeInOutExpo: function(pos) {
        if (pos == 0) return 0;
        if (pos == 1) return 1;
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(2, 10 * (pos - 1));
        return 0.5 * ( - Math.pow(2, -10 * --pos) + 2);
    },
    easeInCirc: function(pos) {
        return - (Math.sqrt(1 - (pos * pos)) - 1);
    },
    easeOutCirc: function(pos) {
        return Math.sqrt(1 - Math.pow((pos - 1), 2))
    },
    easeInOutCirc: function(pos) {
        if ((pos /= 0.5) < 1) return - 0.5 * (Math.sqrt(1 - pos * pos) - 1);
        return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
    },
    easeOutBounce: function(pos) {
        if ((pos) < (1 / 2.75)) {
            return (7.5625 * pos * pos);
        } else if (pos < (2 / 2.75)) {
            return (7.5625 * (pos -= (1.5 / 2.75)) * pos + .75);
        } else if (pos < (2.5 / 2.75)) {
            return (7.5625 * (pos -= (2.25 / 2.75)) * pos + .9375);
        } else {
            return (7.5625 * (pos -= (2.625 / 2.75)) * pos + .984375);
        }
    },
    easeInBack: function(pos) {
        var s = 1.70158;
        return (pos) * pos * ((s + 1) * pos - s);
    },
    easeOutBack: function(pos) {
        var s = 1.70158;
        return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
    },
    easeInOutBack: function(pos) {
        var s = 1.70158;
        if ((pos /= 0.5) < 1) return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));
        return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },
    elastic: function(pos) {
        return - 1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
    },
    swingFromTo: function(pos) {
        var s = 1.70158;
        return ((pos /= 0.5) < 1) ? 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },
    swingFrom: function(pos) {
        var s = 1.70158;
        return pos * pos * ((s + 1) * pos - s);
    },
    swingTo: function(pos) {
        var s = 1.70158;
        return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
    },
    bounce: function(pos) {
        if (pos < (1 / 2.75)) {
            return (7.5625 * pos * pos);
        } else if (pos < (2 / 2.75)) {
            return (7.5625 * (pos -= (1.5 / 2.75)) * pos + .75);
        } else if (pos < (2.5 / 2.75)) {
            return (7.5625 * (pos -= (2.25 / 2.75)) * pos + .9375);
        } else {
            return (7.5625 * (pos -= (2.625 / 2.75)) * pos + .984375);
        }
    },
    bouncePast: function(pos) {
        if (pos < (1 / 2.75)) {
            return (7.5625 * pos * pos);
        } else if (pos < (2 / 2.75)) {
            return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + .75);
        } else if (pos < (2.5 / 2.75)) {
            return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + .9375);
        } else {
            return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + .984375);
        }
    },
    easeFromTo: function(pos) {
        if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
        return - 0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
    },
    easeFrom: function(pos) {
        return Math.pow(pos, 4);
    },
    easeTo: function(pos) {
        return Math.pow(pos, 0.25);
    },
    linear: function(pos) {
        return pos
    },
    sinusoidal: function(pos) {
        return ( - Math.cos(pos * Math.PI) / 2) + 0.5;
    },
    reverse: function(pos) {
        return 1 - pos;
    },
    mirror: function(pos, transition) {
        transition = transition || tween.sinusoidal;
        if (pos < 0.5) return transition(pos * 2);
        else return transition(1 - (pos - 0.5) * 2);
    },
    flicker: function(pos) {
        var pos = pos + (Math.random() - 0.5) / 5;
        return tween.sinusoidal(pos < 0 ? 0 : pos > 1 ? 1 : pos);
    },
    wobble: function(pos) {
        return ( - Math.cos(pos * Math.PI * (9 * pos)) / 2) + 0.5;
    },
    pulse: function(pos, pulses) {
        return ( - Math.cos((pos * ((pulses || 5) - .5) * 2) * Math.PI) / 2) + .5;
    },
    blink: function(pos, blinks) {
        return Math.round(pos * (blinks || 5)) % 2;
    },
    spring: function(pos) {
        return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp( - pos * 6));
    },
    none: function(pos) {
        return 0
    },
    full: function(pos) {
        return 1
    }
}
```

